<!-- Live2D 看板娘容器 -->
<div id="live2d-wrapper">
  <div id="live2d-bg"></div>
  <canvas id="live2d-canvas"></canvas>
  <div id="live2d-dialog"></div>
</div>

<!-- 1. PixiJS -->
<script src="https://unpkg.com/pixi.js@6/dist/browser/pixi.min.js"></script>

<!-- 2. Live2D Cubism Core -->
<script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>

<!-- 3. pixi-live2d-display -->
<script src="https://unpkg.com/pixi-live2d-display@0.4.0/dist/cubism4.min.js"></script>

<script>
  (function () {
    const wrapper   = document.getElementById('live2d-wrapper');
    const canvas    = document.getElementById('live2d-canvas');
    const dialogBox = document.getElementById('live2d-dialog');

    // ======= 音乐配置 =======
    const MUSIC_URL = "./assets/ハローセカイ.mp3";
    const bgm = new Audio(MUSIC_URL);
    bgm.preload = "auto";

    const bgLayer = document.getElementById('live2d-bg');

    // 音乐自然播完时，让背景渐隐
    bgm.addEventListener('ended', () => {
      if (bgLayer) {
        bgLayer.classList.add('fade-out');
      }
    });

    // 限制分辨率，避免手机上超大画布导致 WebGL 崩溃
    const RESOLUTION = Math.min(window.devicePixelRatio || 1, 2);

    const app = new PIXI.Application({
      view: canvas,
      autoStart: true,
      transparent: true,
      autoDensity: true,           // 仍然自适应 DPR
      resolution: RESOLUTION,      // 但最多放大到 2 倍
      antialias: true,
    });

    if (!PIXI.live2d || !PIXI.live2d.Live2DModel) {
      console.error('pixi-live2d-display 未正确加载');
      return;
    }
    const Live2DModel    = PIXI.live2d.Live2DModel;
    const MotionPriority = PIXI.live2d.MotionPriority;

    const MODEL_URL = "./assets/v2_clb01_21miku_t03/v2_clb01_21miku_t03.model3.json";

    Live2DModel.from(MODEL_URL, { autoInteract: false }).then(model => {
      app.stage.addChild(model);

      // 禁用 idle 自动待机动作
      if (model.internalModel.motionManager && model.internalModel.motionManager.groups) {
        model.internalModel.motionManager.groups.idle = '';
      }

      

      function layoutModel() {
        // 用实际 DOM 尺寸，而不是 renderer 内部尺寸
        const rect = wrapper.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;

        const isMobile = window.innerWidth <= 768;   

        if (isMobile) {
          // —— 手机：人物放屏幕正中，稍微偏下一点 —— 
          model.anchor.set(0.5, 0.5);    // 以人物中心为锚点
          model.scale.set(0.25);         

          model.x = w * 0.5;
          model.y = h * 0.5;            // 0.5 正中，0.55 稍微偏下
        } else {
          // —— PC：站在底部中央 ——
          model.anchor.set(0.5, 0.35);    // 脚附近为锚点
          model.scale.set(0.3);

          model.x = w * 0.5;
          model.y = h * 0.5;                   // 贴底
        }
      }

      function resizeApp() {
        const rect = wrapper.getBoundingClientRect();
        app.renderer.resize(rect.width, rect.height);
        layoutModel();
      }


      resizeApp();
      ['resize', 'orientationchange', 'fullscreenchange', 'webkitfullscreenchange'].forEach(ev => {
        window.addEventListener(ev, resizeApp);
      });

      // 鼠标控制视线
      window.addEventListener('pointermove', (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        model.focus(x, y);
      });

      // ======= 工具函数 =======
      function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      function playBodyMotion(groupName, priority = MotionPriority.FORCE) {
        const settings = model.internalModel.settings;
        const motions  = settings.motions || settings.Motions || {};
        const group    = motions[groupName];
        if (!group || !group.length) {
          console.warn('没有找到身体动作组:', groupName);
          return;
        }
        return model.motion(groupName, 0, priority);
      }

      function playFaceMotion(groupName, priority = MotionPriority.FORCE) {
        const settings = model.internalModel.settings;
        const motions  = settings.motions || settings.Motions || {};
        const group    = motions[groupName];
        if (!group || !group.length) {
          console.warn('没有找到面部动作组:', groupName);
          return;
        }
        return model.motion(groupName, 0, priority);
      }

      // ======= 眨眼 =======
      const coreModel = model.internalModel.coreModel;
      const EYE_L_ID = 'ParamEyeLOpen';
      const EYE_R_ID = 'ParamEyeROpen';

      // 眨眼状态机
      let blinkState = 'wait';   // 'wait' | 'closing' | 'opening'
      let waitTimer = 0;
      let phaseTimer = 0;
      let nextBlinkTime = 2 + Math.random() * 3;   // 下一次眨眼间隔（秒）
      const blinkPhaseDuration = 0.08;             // 闭眼 / 睁眼各自时长（秒）

      // 每次眨眼前记录当时的基础眼睛开合
      let baseEyeL = 1.0;
      let baseEyeR = 1.0;

      app.ticker.add(() => {
        if (!coreModel) return;

        // 用真实时间，每帧毫秒 / 1000
        const dt = app.ticker.deltaMS / 1000;

        if (blinkState === 'wait') {
          // 等待下一次眨眼
          waitTimer += dt;
          if (waitTimer >= nextBlinkTime) {
            waitTimer = 0;
            blinkState = 'closing';
            phaseTimer = 0;

            // 每次眨眼前，记录当前眼睛基础值（可能不是 1）
            baseEyeL = coreModel.getParameterValueById(EYE_L_ID);
            baseEyeR = coreModel.getParameterValueById(EYE_R_ID);
          }
        } else if (blinkState === 'closing') {
          // 从 baseEye -> 0 的闭眼阶段
          phaseTimer += dt;
          let t = phaseTimer / blinkPhaseDuration;
          if (t > 1) t = 1;

          const vL = baseEyeL * (1 - t);
          const vR = baseEyeR * (1 - t);
          coreModel.setParameterValueById(EYE_L_ID, vL);
          coreModel.setParameterValueById(EYE_R_ID, vR);

          if (t >= 1) {
            blinkState = 'opening';
            phaseTimer = 0;
          }
        } else if (blinkState === 'opening') {
          // 从 0 -> baseEye 的睁眼阶段
          phaseTimer += dt;
          let t = phaseTimer / blinkPhaseDuration;
          if (t > 1) t = 1;

          const vL = baseEyeL * t;
          const vR = baseEyeR * t;
          coreModel.setParameterValueById(EYE_L_ID, vL);
          coreModel.setParameterValueById(EYE_R_ID, vR);

          if (t >= 1) {
            blinkState = 'wait';
            waitTimer = 0;
            nextBlinkTime = 2 + Math.random() * 3;   // 下一次眨眼间隔再随机
          }
        }
      });


      // ======= 初始动作 =======
      (async () => {
        playBodyMotion('w-adult12-glad');
        await delay(1000);
        playFaceMotion('face_band_closeeye_03');

      })();

      // ======= LRC台词 =======
      const lrcText = `
[00:00.59]きっと届くはず　きっと見えるはず 
一定能传达给你 一定能把你看见
[00:09.93]そんな会ってみたい未来を　僕はひとりきりのセカイで 
那般我们想追逐的未来 有我在这孤身一人的世界
[00:15.65]ずっとそう歌うたっていた 
一直这样歌唱着它们
[00:20.57]
[00:28.06]今聞こえたよ　ほら少しだけ 
现在我听到了 你看我能够稍微
[00:34.24]君を感じたよ　メロディーがリンクする 
感受到你了啊 旋律交织将我们连结
[00:41.01]今繋がるよ　今重なるよ 
此刻情感相连 此刻心愿交汇
[00:46.95]伝えたかったこと　山ほどあるんだけどどうしよう 
想要传达的心意 堆得像山一样 该怎么办呢
[00:55.09]
[00:57.94]見たこともない顔で　君は君をダメと言うけど 
你面露我所未见的神情 坦言自己百无一用
[01:03.11]未来にいる理想の君を　今の君に押し付け過ぎないで 
但我愿你不必过于执着 去强求未来那个完美的你
[01:10.84]見たこともない景色　見せ合ういつかが来るまで 
未曾见过的光景 直至将其互相分享的那天到来
[01:15.78]つらいこと　泣きたくなること　たまには預け合おう 
就把彼此心中的辛酸与热泪 时不时也寄托给对方吧
[01:21.82]
[01:21.95]ハロー、セカイ　僕の声はちゃんと届いてるかい 
Hello,SEKAI 我的声音是否清晰明朗地传到你耳边呢
[01:28.55]思ったよりも大丈夫　君はひとりなんかじゃない 
无需为我如此担心 你有我们一路相伴
[01:34.68]ハロー、セカイ　君の声もちゃんと届いてるよ 
Hello,SEKAI 你的声音有好好地深入我心
[01:41.12]思ったよりも最高だ　僕もひとりなんかじゃない 
那份歌声远超期待 我也不再孤身一人
[01:47.02]
[01:47.02]行くよジャンプ　跳ねるダンス 
来吧 jump 跳起来 dance
[01:50.22]いらない不安なんて踏んじゃってこう 
踏过多余的忧虑坚定前进吧
[01:53.85]ああでもこうでもないも　そんなのどうでもいいよ 
这样不行那样也不行 这些事情都无所谓啦
[01:56.97]やりたいようにやろう　ハローハロー 
随心所欲地放手做吧 Hello Hello
[01:59.67]
[01:59.67]もう一回ジャンプ　回るダンス 
再一次 jump! 又一圈dance
[02:02.83]行きたい未来　きっともうすぐだよ 
想要去亲历的未来 想必就近在咫尺吧
[02:06.45]ああでもこうでもないも　そんなのどうでもいいよ 
这样不行那样也不行 这些事情都无所谓啦
[02:09.57]やりたいようにやろう 
随心所欲地放手做吧
[02:12.52]
[02:12.61]飛び込んでいこう　僕らのセカイが 
你我一齐纵身跃入 我们身处的世界
[02:15.88]正解か不正解かわからなくても 
其中的对与错即便我们还未理清
[02:18.73]僕にある想いも　君にある願いも 
可我所具备的感情 你所具备的心愿
[02:21.82]きっと消えないんだよ　ずっとセカイは終わらないよ 
一定不会消失无踪 世界也将永不谢幕
[02:25.60]
[02:25.81]今繋がるよ　今重なるよ 
此刻情感相连 此刻心愿交汇
[02:32.14]ほら聞こえるよ　ほら伝わるよ僕ら 
看吧 我们听见了哦 看吧 我们的心声传递出去了哦
[02:38.51]
      `;

      function parseLRC(text) {
        const lines   = text.split('\n');
        const result  = [];
        let lastEntry = null;

        for (let raw of lines) {
          const line = raw.replace(/\r/g, '');
          if (!line.trim()) continue;  // 空行直接跳过

          const match = line.match(/\[(\d{2}):(\d{2})(?:\.(\d{1,3}))?]/);
          if (match) {
            const min = parseInt(match[1], 10);
            const sec = parseInt(match[2], 10);
            const ms  = match[3] ? parseInt(match[3].padEnd(3, '0'), 10) : 0;
            const content = line
              .replace(/\[\d{2}:\d{2}(?:\.\d{1,3})?]/, '')
              .trim();  // 允许为空 → 用来关气泡

            const entry = {
              time: min * 60 + sec + ms / 1000,
              text: content
            };
            result.push(entry);
            lastEntry = entry;
          } else {
            // 无时间标签但有文字：作为上一句的“续行”
            if (lastEntry) {
              if (lastEntry.text) {
                lastEntry.text += '\n' + line.trim();
              } else {
                lastEntry.text = line.trim();
              }
            }
          }
        }

        return result.sort((a, b) => a.time - b.time);
      }

      const scriptData   = parseLRC(lrcText);
      let currentIndex   = -1;
      let finishedOnce   = false;
      let lyricsStarted  = false;
      let dialogTimer    = null;
      let startTime      = 0;   // 台词开始的时间戳（毫秒）

      // ======= 台词刷新函数（现在跟 startLyrics 在同一作用域）=======
      function updateDialog() {
        if (!scriptData.length) return;

        const elapsed = (Date.now() - startTime) / 1000; // 秒
        let idx = currentIndex;

        for (let i = scriptData.length - 1; i >= 0; i--) {
          if (elapsed >= scriptData[i].time) {
            idx = i;
            break;
          }
        }

        if (idx !== currentIndex && idx >= 0) {
          currentIndex = idx;
          const line = scriptData[idx];

          if (line.text && line.text.length > 0) {
            dialogBox.textContent = line.text;
            dialogBox.classList.add('show');
          } else {
            dialogBox.textContent = "";
            dialogBox.classList.remove('show');
          }
        }

        const lastTime = scriptData[scriptData.length - 1].time;
        if (!finishedOnce && elapsed >= lastTime) {
          finishedOnce = true;

          (async () => {
            playFaceMotion('face_band_smile_08');
            await delay(300);
            playBodyMotion('w-adult01-shakehand');
            await delay(4000);
            playBodyMotion('w-normal01-glad');
          })();

          if (dialogTimer) {
            clearInterval(dialogTimer);
            dialogTimer = null;
          }
        }
      }

      // ======= 音乐 + 台词启动函数（现在也在同一作用域里）=======
      function startLyrics() {
        if (lyricsStarted) return;
        lyricsStarted = true;
        startTime     = Date.now();
        dialogTimer   = setInterval(updateDialog, 100);
      }

      function startBgmAndLyrics() {
        bgm.play().then(() => {
          // 自动播放成功：立刻启动台词
          startLyrics();
        }).catch(err => {
          console.warn("音乐自动播放被浏览器阻止，将在用户点击页面后开始播放和台词。", err);
          const resume = () => {
            bgm.play().then(() => {
              startLyrics();
            }).catch(() => {});
            document.removeEventListener('click', resume);
          };
          document.addEventListener('click', resume, { once: true });
        });
      }

      // 模型加载完成后再尝试启动音乐 + 台词
      startBgmAndLyrics();
    }).catch(err => {
      console.error("Live2D 模型加载失败：", err);
    });
  })();
</script>

<style>
  #live2d-wrapper {
    position: fixed;
    inset: 0;
    z-index: 9999;
    pointer-events: none;
    overflow: hidden;
  }

#live2d-bg {
  position: absolute;
  inset: 0;
  background-image: url("./assets/bg_area_25.webp"); /* 换成你的图片地址 */
  background-size: cover;      /* 填满屏幕 */
  background-position: center; /* 居中裁切 */
  background-repeat: no-repeat;
  opacity: 1;
  transition: opacity 1.5s ease;  /* 渐隐时间可改 */
  z-index: 0;
  pointer-events: none;
}

/* 渐隐结束状态 */
#live2d-bg.fade-out {
  opacity: 0;
}

#live2d-canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  display: block;
  pointer-events: none;
  z-index: 1;
}

  #live2d-dialog {
    position: absolute;
    bottom: 200px;
    right: 50%;
    transform: translateX(50%);
    max-width: 350px;
    padding: 8px 10px;
    background: rgba(0, 0, 0, 0.65);
    color: #fff;
    font-size: 16px;
    border-radius: 12px;
    line-height: 1.4;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    white-space: pre-line; /* 支持 \n 换行 */
    z-index: 2; /* 在最上层 */
  }

  #live2d-dialog.show {
    opacity: 1;
  }
</style>